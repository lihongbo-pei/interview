# 场景题

## 08、在 2G 大小的文件中，找出高频 top100 的单词

> 统计几十个URL出现的次数，如何找到出现次数Top k的URL

1. 分块读取（内存控制）
我们可以按 4MB 为单位分块读取文件，使用 BufferReader 逐行读取避免内存溢出。我们也可以动态调整分块大小（根据实际内存情况）

2. 并行处理（性能优化）
使用线程池处理每个分块，**每个线程独立统计局部词频**，合并结果时使用 `ConcurrentHashMap` 保证线程安全。

3. 全局合并（高效聚合）
使用 Map.merge 方法进行原子累加，同步代码块保证并发安全

4. Top K 筛选（堆排序优化）
维护大小为 100 的最小堆，最终排序输出结果。
具体过程就是如果遍历到的词的出现次数**大于堆顶上词的出现次数**，那么可以用新遍历到的词替换堆顶的词，然后重新调整这个堆为小顶堆。当遍历完所有的文件后，这个小顶堆中的词就是出现频率最高的100个词。

1. 分块读取 → 2. 局部统计 → 3. 全局合并 → 4. 堆排序筛选

具体代码如下：

```java
import java.io.*;
import java.nio.file.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.stream.*;

public class Top100WordsFinder {

    private static final int CHUNK_SIZE = 4 * 1024 * 1024; // 4MB
    private static final int TOP_K = 100;

    public static void main(String[] args) throws IOException, InterruptedException {
        String filePath = "path/to/your/2G/file.txt"; // 替换为你的文件路径
        List<String> top100Words = findTop100Words(filePath);
        top100Words.forEach(System.out::println);
    }

    private static List<String> findTop100Words(String filePath) throws IOException, InterruptedException {
        // Step 1: 分块读取
        List<String> allLines = Files.readAllLines(Paths.get(filePath), StandardCharsets.UTF_8)
                .parallelStream()
                .collect(Collectors.toList());

        // Step 2: 局部统计
        Map<String, Long> wordCounts = new ConcurrentHashMap<>();
        allLines.parallelStream().forEach(line -> {
            String[] words = line.split("\\s+");
            for (String word : words) {
                word = word.toLowerCase(); // 转换为小写
                wordCounts.merge(word, 1L, Long::sum);
            }
        });

        // Step 3: 全局合并
        // 使用ConcurrentHashMap已经自动处理了并发合并

        // Step 4: Top K 筛选
        PriorityQueue<Map.Entry<String, Long>> heap = new PriorityQueue<>(
                TOP_K,
                (e1, e2) -> e2.getValue().compareTo(e1.getValue())
        );
        wordCounts.entrySet().forEach(entry -> {
            if (heap.size() < TOP_K) {
                heap.add(entry);
            } else if (entry.getValue() > heap.peek().getValue()) {
                heap.poll();
                heap.add(entry);
            }
        });

        return new ArrayList<>(heap);
    }
}
```

## 19、接口防刷怎么实现

> 服务端API限流怎么实现，令牌桶算法的缺陷

首先想到的是**限流**，比如使用**令牌桶或漏桶算法**，限制每个用户或 IP 的请求频率。然后可能需要验证码，特别是对于登录、注册等敏感接口。还有黑名单机制，自动封禁频繁违规的 IP 或用户账号。

另外，设备指纹和用户行为分析也是重要的一部分，可以通过收集客户端信息来识别唯一设备，分析请求模式是否异常。比如，正常用户不会在短时间内发起大量相同请求。

（1）IP 限流

分布式限流：使用 Redis + Lua 脚本实现原子化计数器（如令牌桶算法）。

```lua
-- KEYS[1]=限流Key（如ip:127.0.0.1），
-- ARGV[1]=时间窗口（秒），表示令牌桶的有效期。
-- ARGV[2]=最大请求数，即令牌桶的最大容量。
local key = KEYS[1]
local limit = tonumber(ARGV[2])
local window = tonumber(ARGV[1])
local current = redis.call('GET', key) or 0
if tonumber(current) >= limit then
    return 0 -- 触发限流
else
    redis.call('INCR', key)
    redis.call('EXPIRE', key, window)
    return 1 -- 允许通过
end
```

```java
String key = "rate_limit:ip" + clientIP;
boolean allowed = redisEval(luaScript, Colltecions.singletonList(key), "60", "100");
```

令牌桶算法的缺陷

1. **突发流量处理**：令牌桶算法允许突发流量，但如果令牌生成速度跟不上请求速度，可能会导致请求被拒绝。
2. **时间精度问题**：令牌生成和消耗的时间精度可能不够高，特别是在高并发场景下，可能导致令牌生成和消耗的不准确。
3. **资源消耗**：需要维护一个令牌桶，可能会消耗一定的内存和计算资源。
4. **复杂性**：算法实现相对复杂，需要考虑令牌生成和消耗的同步问题。
5. **不公平性**：如果多个客户端共享同一个令牌桶，可能会导致某些客户端的请求被不公平地限制。

（2）设备指纹识别

```java
// 生成设备指纹（示例）
public String generateDeviceFingerprint(HttpServletRequest request) {
    String userAgent = request.getHeader("User-Agent");
    String ip = request.getRemoteAddr();
    String acceptLanguage = request.getHeader("Accept-Language");
    return DigestUtils.md5Hex(ip + userAgent + acceptLanguage); // 简单哈希
}
```

更进一步，可以客户端埋点采集硬件参数（如屏幕分辨率、CPU 型号）。

（3）请求签名

客户端生成请求参数的有序拼接字符串。

使用 HMAC-SHA256 和密钥生成签名。

将签名附加到请求头

```java
// 客户端生成签名
String data = "param1=value1&param2=value2&timestamp=1620000000";
String signature = HmacUtils.hmacSha256Hex(apiKeySecret, data);
```


```java
// 服务端验证
String serverSign = HmacUtils.hmacSha256Hex(apiKeySecret, data);
if (!serverSign.equals(clientSign)) {
    throw new ApiSecurityException("签名无效");
}
```

（4）添加黑名单

自建黑名单库，自动封禁频繁触发规则的设备/IP。
