# 设计模式

## 设计模式的六大原则

**1、开闭原则（Open Close Principle）**

开闭原则的意思是：**对扩展开放，对修改关闭**。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。

**2、里氏代换原则（Liskov Substitution Principle）**

里氏代换原则是**面向对象设计**的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

**3、依赖倒转原则（Dependence Inversion Principle）**

这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。

**4、接口隔离原则（Interface Segregation Principle）**

这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。

**5、迪米特法则，又称最少知道原则（Demeter Principle）**

最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。

**6、合成复用原则（Composite Reuse Principle）**

合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。



为什么说继承容易违反里氏替换原则LSP，相比于继承，组合如何更好的遵守LSP？

> 北森云AI面

1、继承易违反LSP的核心原因

LSP要求：子类可完全替代父类，且不破坏原有程序逻辑。
继承是“is-a”关系，子类会继承父类所有公开属性和方法，若子类重写父类方法时改变了原逻辑（如限制输入、修改返回语义），就会导致“子类不能替代父类”，违反LSP。
例：父类Bird有fly()方法，子类Ostrich（鸵鸟）继承后，重写fly()抛出“不能飞”异常——此时用Ostrich替代Bird，会导致依赖Bird.fly()的代码崩溃，违反LSP。

2、组合为何更易遵守LSP

组合是“has-a”关系，即一个类通过持有另一个类的实例（而非继承）来复用其功能，核心优势是解耦依赖、避免语义入侵：

- 组合不强制“子类替代父类”，而是通过调用被持有对象的方法实现功能，不会继承多余的、不适合自身的行为（如鸵鸟无需继承Bird的fly()，而是持有Bird的非飞行相关功能实例）；

- 组合通过接口依赖（而非具体父类），被持有对象若符合接口规范，可灵活替换，且不影响当前类的对外行为，自然满足“替换后不破坏逻辑”的LSP核心要求。

例：重构上述场景——定义Flyable接口（含fly()），Sparrow（麻雀）实现Flyable；Ostrich不继承Bird，而是通过组合持有Bird的“觅食、走路”功能实例，且不依赖Flyable。此时Ostrich与Sparrow是独立类，无需互相替代，完全遵守LSP。

简单说：继承是“强绑定”，子类易因重写破坏父类语义；组合是“弱关联”，通过持有实例复用功能，不涉及“替代关系”，天然契合LSP。



## 单例模式

**意图**：确保一个类只有一个实例，并提供一个全局访问点来访问该实例。

**主要解决**：频繁创建和销毁全局使用的类实例的问题。

**关键代码**：构造函数是私有的。

### 单例模式的几种实现方式

1、懒汉式，线程不安全

```java
public class Singleton {
    // 创建 SingleObject 的一个对象
    private static Singleton instance;  
    // 让构造函数为 private，这样该类就不会被实例化
    private Singleton (){}  
  
    // 获取唯一可用的对象
    public static Singleton getInstance() {  
        if (instance == null) {  
            instance = new Singleton();  
        }  
        return instance;  
    }  
}
```

2、懒汉式，线程安全

和第一种方式几乎一样，就只是在创建实例的时候多了一个 `synchronized` 。（在 static 后添加 synchronized）

3、饿汉式

一上来就创建一个实例，相比于懒汉式，饿汉式不需要对 `instance` 判空，即不需要 `if (instance == null)` 。

```java
public class Singleton {  
    private static Singleton instance = new Singleton();  
    private Singleton (){}  
    public static Singleton getInstance() {  
    	return instance;  
    }  
}
```

4、双检锁/双重校验锁（DCL，即 double-checked locking）

多了 volatile 和 synchronized

```java
public class Singleton {  
    private volatile static Singleton singleton;  
    private Singleton (){}  
    public static Singleton getSingleton() {  
    if (singleton == null) {  
        synchronized (Singleton.class) {  
            if (singleton == null) {  
                singleton = new Singleton();  
            }  
        }  
    }  
    return singleton;  
    }  
}
```

5、登记式/静态内部类

```java
public class Singleton {  
    private static class SingletonHolder {  
    	private static final Singleton INSTANCE = new Singleton();  
    }  
  
    private Singleton (){}  
  
    public static final Singleton getInstance() {  
        return SingletonHolder.INSTANCE;  
    }  
}
```



6、枚举

## 装饰器模式

**装饰器（Decorator）模式** 可以在不改变原有对象的情况下拓展其功能。

装饰器模式通过**组合**替代继承来扩展原始类的功能，在一些继承关系比较复杂的场景（IO 这一场景各种类的继承关系就比较复杂）更加实用。

## 了解过适配器模式吗？

适配器模式是一种结构型设计模式，用于**解决接口不兼容问题**，使原本无法协同工作的类能够协同工作。其核心思想是通过一个中间层(适配器)转换接口，类似于现实世界的电源适配器。

一、模式结构(三个关键角色)
1、目标接口(Target)
客户端期望的接口规范
例如:USB 接口规范(包含 transferData()方法)

2、被适配者(Adaptee)
已存在的、需要被复用的组件，但其接口与目标不兼容
例如:TypeCDevice 类(只有 transmitData()方法)

3、适配器(Adapter)
实现目标接口，并持有被适配者的引用
在目标接口方法中调用被适配者的功能
例如:TypeCToUSBAdapter 实现 USB 接口，内部调用 TypeCDevice.transmitData()

二、实现方式对比

| 类型       | 类适配器                                          | 对象适配器                                                   |
| ---------- | ------------------------------------------------- | ------------------------------------------------------------ |
| 实现机制   | 继承被适配者 + 实现目标接口                       | 组合被适配者 + 实现目标接口                                  |
| 灵活性     | 较低（Java 单继承限制）                           | 较高（推荐）                                                 |
| 代码耦合   | 紧耦合（直接继承）                                | 松耦合（通过组合）                                           |
| 适配多个类 | 不支持（单继承限制）                              | 支持（可组合多个 Adaptee）                                   |
| 示例代码   | `class Adapter extends Adaptee implements Target` | `class Adapter implements Target { private Adaptee adaptee; }` |

## 工厂模式

> 北森云AI面

工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一，它提供了一种创建对象的方式，使得创建对象的过程与使用对象的过程分离。

工厂模式提供了一种创建对象的方式，而无需指定要创建的具体类。

通过使用工厂模式，可以将对象的创建逻辑封装在一个工厂类中，而不是在客户端代码中直接实例化对象，这样可以提高代码的可维护性和可扩展性。

### 工厂模式的类型

**1、简单工厂模式（Simple Factory Pattern）**：

- 简单工厂模式不是一个正式的设计模式，但它是工厂模式的基础。它使用一个单独的工厂类来创建不同的对象，根据传入的参数决定创建哪种类型的对象。

**2、工厂方法模式（Factory Method Pattern）**：

- 工厂方法模式定义了一个创建对象的接口，但由子类决定实例化哪个类。工厂方法将对象的创建延迟到子类。

**3、抽象工厂模式（Abstract Factory Pattern）**：

- 抽象工厂模式提供一个创建一系列相关或互相依赖对象的接口，而无需指定它们具体的类。



工厂模式用于创建对象，NIO 中大量用到了工厂模式，比如 `Files` 类的 `newInputStream` 方法用于创建 `InputStream` 对象（静态工厂）、 `Paths` 类的 `get` 方法创建 `Path` 对象（静态工厂）、`ZipFileSystem` 类（`sun.nio`包下的类，属于 `java.nio` 相关的一些内部实现）的 `getPath` 的方法创建 `Path` 对象（简单工厂）。

```java
InputStream is = Files.newInputStream(Paths.get(generatorLogoPath))
```

## 观察者模式



## 建造者模式

## 组合模式

> 北森云AI面

组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据**树形结构**来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。

这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。

我们通过下面的实例来演示组合模式的用法。实例演示了一个组织中员工的层次结构。

### 结构

**组合模式的核心角色包括：**

- **组件（Component）:**
  - 定义了组合中所有对象的通用接口，可以是抽象类或接口。它声明了用于访问和管理子组件的方法，包括添加、删除、获取子组件等。
- **叶子节点（Leaf）:**
  - 表示组合中的叶子节点对象，叶子节点没有子节点。它实现了组件接口的方法，但通常不包含子组件。
- **复合节点（Composite）:**
  - 表示组合中的复合对象，复合节点可以包含子节点，可以是叶子节点，也可以是其他复合节点。它实现了组件接口的方法，包括管理子组件的方法。
- **客户端（Client）:**
  - 通过组件接口与组合结构进行交互，客户端不需要区分叶子节点和复合节点，可以一致地对待整体和部分。

## 策略模式

意图：将每个算法封装起来，使它们可以互换使用。

主要解决的问题：解决在多种相似算法存在时，使用条件语句（如if...else）导致的复杂性和难以维护的问题。

使用场景：当一个系统中有许多类，它们之间的区别仅在于它们的行为时。

### 优点

1. **算法切换自由**：可以在运行时根据需要切换算法。
2. **避免多重条件判断**：消除了复杂的条件语句。
3. **扩展性好**：新增算法只需新增一个策略类，无需修改现有代码。

## 责任链模式

- 在Java Web开发中，责任链模式有广泛应用，如过滤器链、拦截器等。
