# 设计模式

## 单例模式

**意图**：确保一个类只有一个实例，并提供一个全局访问点来访问该实例。

**主要解决**：频繁创建和销毁全局使用的类实例的问题。

**关键代码**：构造函数是私有的。

### 单例模式的几种实现方式

1、懒汉式，线程不安全

```java
public class Singleton {
    // 创建 SingleObject 的一个对象
    private static Singleton instance;  
    // 让构造函数为 private，这样该类就不会被实例化
    private Singleton (){}  
  
    // 获取唯一可用的对象
    public static Singleton getInstance() {  
        if (instance == null) {  
            instance = new Singleton();  
        }  
        return instance;  
    }  
}
```

2、懒汉式，线程安全

和第一种方式几乎一样，就只是在创建实例的时候多了一个 `synchronized` 。（在 static 后添加 synchronized）

3、饿汉式

一上来就创建一个实例，相比于懒汉式，饿汉式不需要对 `instance` 判空，即不需要 `if (instance == null)` 。

```java
public class Singleton {  
    private static Singleton instance = new Singleton();  
    private Singleton (){}  
    public static Singleton getInstance() {  
    	return instance;  
    }  
}
```

4、双检锁/双重校验锁（DCL，即 double-checked locking）

多了 volatile 和 synchronized

```java
public class Singleton {  
    private volatile static Singleton singleton;  
    private Singleton (){}  
    public static Singleton getSingleton() {  
    if (singleton == null) {  
        synchronized (Singleton.class) {  
            if (singleton == null) {  
                singleton = new Singleton();  
            }  
        }  
    }  
    return singleton;  
    }  
}
```

5、登记式/静态内部类

```java
public class Singleton {  
    private static class SingletonHolder {  
    	private static final Singleton INSTANCE = new Singleton();  
    }  
  
    private Singleton (){}  
  
    public static final Singleton getInstance() {  
        return SingletonHolder.INSTANCE;  
    }  
}
```



6、枚举

## 装饰器模式

**装饰器（Decorator）模式** 可以在不改变原有对象的情况下拓展其功能。

装饰器模式通过**组合**替代继承来扩展原始类的功能，在一些继承关系比较复杂的场景（IO 这一场景各种类的继承关系就比较复杂）更加实用。

## 了解过适配器模式吗？

适配器模式是一种结构型设计模式，用于**解决接口不兼容问题**，使原本无法协同工作的类能够协同工作。其核心思想是通过一个中间层(适配器)转换接口，类似于现实世界的电源适配器。

一、模式结构(三个关键角色)
1、目标接口(Target)
客户端期望的接口规范
例如:USB 接口规范(包含 transferData()方法)

2、被适配者(Adaptee)
已存在的、需要被复用的组件，但其接口与目标不兼容
例如:TypeCDevice 类(只有 transmitData()方法)

3、适配器(Adapter)
实现目标接口，并持有被适配者的引用
在目标接口方法中调用被适配者的功能
例如:TypeCToUSBAdapter 实现 USB 接口，内部调用 TypeCDevice.transmitData()

二、实现方式对比

| 类型       | 类适配器                                          | 对象适配器                                                   |
| ---------- | ------------------------------------------------- | ------------------------------------------------------------ |
| 实现机制   | 继承被适配者 + 实现目标接口                       | 组合被适配者 + 实现目标接口                                  |
| 灵活性     | 较低（Java 单继承限制）                           | 较高（推荐）                                                 |
| 代码耦合   | 紧耦合（直接继承）                                | 松耦合（通过组合）                                           |
| 适配多个类 | 不支持（单继承限制）                              | 支持（可组合多个 Adaptee）                                   |
| 示例代码   | `class Adapter extends Adaptee implements Target` | `class Adapter implements Target { private Adaptee adaptee; }` |

## 工厂模式

工厂模式用于创建对象，NIO 中大量用到了工厂模式，比如 `Files` 类的 `newInputStream` 方法用于创建 `InputStream` 对象（静态工厂）、 `Paths` 类的 `get` 方法创建 `Path` 对象（静态工厂）、`ZipFileSystem` 类（`sun.nio`包下的类，属于 `java.nio` 相关的一些内部实现）的 `getPath` 的方法创建 `Path` 对象（简单工厂）。

```java
InputStream is = Files.newInputStream(Paths.get(generatorLogoPath))
```

## 观察者模式



## 建造者模式



## 策略模式

意图：将每个算法封装起来，使它们可以互换使用。

主要解决的问题：解决在多种相似算法存在时，使用条件语句（如if...else）导致的复杂性和难以维护的问题。

使用场景：当一个系统中有许多类，它们之间的区别仅在于它们的行为时。

### 优点

1. **算法切换自由**：可以在运行时根据需要切换算法。
2. **避免多重条件判断**：消除了复杂的条件语句。
3. **扩展性好**：新增算法只需新增一个策略类，无需修改现有代码。

