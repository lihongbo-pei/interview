# CCTECH

## 笔试

- 欧姆定律：$I = U / R $

- 串联分压电路中，电压与电阻成正比。

11.某分页系统进程空间共32个页面，页面大小为1KB，内存大小为32KB，某时刻内存中该进程页表和对应物理块号如下，则逻辑地址0A6AH对应的物理地址是（）。
页表

| 页号 | 块号 |
| ---- | ---- |
| 0    | 4    |
| 1    | 9    |
| 2    | 11   |
| 3    | 6    |

逻辑地址 `0A6AH` 转二进制：$0A6A_{16}=0000  1010  0110  1010_2$





12.以下IP地址中，哪一个是所在网络的广播地址（）。
A 201.119.23.79/28	
B 55.66.77.85/27
C 110.29.10.97/26
D 121.10.201.198/27

✅ **关键步骤**

广播地址 = 网络地址 + 主机部分全为 1

计算方式：

1. 根据掩码确定每个子网的主机数。
2. 找出该IP所在子网的起始地址（网络地址）。
3. 该子网的最后一个地址就是广播地址。

**A. 201.119.23.79/28**

- 子网掩码：255.255.255.240

- 每个子网主机数：$2^{(32-28)} = 16$ 个地址（0–15）

- 子网划分：
   第四段每个子网范围：

  ```
  0–15
  16–31
  32–47
  48–63
  64–79
  80–95
  ```

  IP是 79，属于 **64–79** 这个子网。
   → 广播地址 = **201.119.23.79**

✅ A 是广播地址。



```sql
SELECT id, 'apple' AS fruit, apple AS price FROM 价格表
UNION ALL
SELECT id, 'banana' AS fruit, banana AS price FROM 价格表
UNION ALL
SELECT id, 'orange' AS fruit, orange AS price FROM 价格表
ORDER BY id;
```

下面C++语句重正确的是（语句3）

```c++
const int ci = 1;
const int &p1 = ci;
p1 = 0;  // 语句1
int &p2 = ci;  // 语句2
const int &p3 = 2;  // 语句3
int & p4 = p3 * 2;  // 语句4
```



## 4、struct 和 class 的区别？

1. 首先说一下C中的结构体和C++中的结构体的异同： ![在这里插入图片描述](https://img-blog.csdnimg.cn/caf73931041b4ab3bd090afa7123e553.png)
2. C++中 struct 与 class 的区别： 
   - 内部成员变量及成员函数的默认访问属性：struct 默认防控属性是 public 的，而 class 默认的访问属性是private的 
   - 继承关系中默认访问属性的区别：在继承关系，struct 默认是 public 的，而 class 是 private class这个关键字还可用于定义模板参数，就等同于 typename；而strcut不用与定义模板参数

## 20、引用作为函数参数以及返回值的好处

对比值传递，引用传参的好处：

1. 在函数内部可以对此参数进行修改
2. 提高函数调用和运行的效率（所以没有了传值和生成副本的时间和空间消耗） 
   - **值传递：** 形参是实参的拷贝，改变形参的值并不会影响外部实参的值。从被调用函数的角度来说，值传递是单向的（实参->形参），参数的值只能传入，不能传出。当函数内部需要修改参数，并且不希望这个改变影响调用者时，采用值传递。 
   - **指针传递：** 形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作 
   - **引用传递：** 形参相当于是实参的“别名”，对形参的操作其实就是对实参的操作，在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。 用引用作为返回值最大的好处就是在内存中不产生被返回值的副本。

但是有以下的限制：

1. 不能返回局部变量的引用。因为函数返回以后局部变量就会被销毁
2. 不能返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一 个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak
3. 可以返回类成员的引用，但是最好是const。因为如果其他对象可以获得该属性的非常量的引用，那么对该属性的单纯赋值就会破坏业务规则的完整性。

## 面试

### 11、堆和栈的区别

1. 堆栈空间分配区别： 
   - 栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈； 
   - 堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。
2. 堆栈的缓存方式区别 
   - 栈：是内存中存储值类型的，大小为2M（window，linux下默认为8M，可以更改），超出则会报错，内存溢出； 
   - 堆：内存中，存储的是引用数据类型，引用数据类型无法确定大小，堆实际上是一个在内存中使用到内存中零散空间的链表结构的存储空间，堆的大小由引用类型的大小直接决定，引用类型的大小的变化直接影响到堆的变化。
3. 堆栈数据结构上的区别 
   - 堆（数据结构）：堆可以被看成是一棵树，如：堆排序；
   -  栈（数据结构）：一种先进后出的数据结构。

**C++内存区域中堆和栈的区别：** 

管理方式不同：栈是由编译器自动管理，无需我们手工控制；对于堆来说，释放由程序员完成，容易产生内存泄漏。 

空间大小不同：一般来讲，在32为系统下面，堆内存可达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定空间大小的，例如，在vc6下面，默认的栈大小好像是1M。当然，也可以自己修改：打开工程。 project-->setting-->link，在category中选中output，然后再reserve中设定堆栈的最大值和 commit。 

能否产生碎片：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题。 

生长方向不同：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方式是向下的，是向着内存地址减小的方向增长。 

分配方式不同：堆都是动态分配的；栈静态分配由编译器完成，比如局部变量的分配 

分配效率不同：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是c/c++库函数提供的，机制很复杂。库函数会按照一定的算法进行分配。显然，堆的效率比栈要低得多。 进程内存中的映像，主要有代码区，堆（动态存储区，new/delete的动态数据），栈，静态存储区

**堆和自由存储区的区别？** 总的来说，堆是C语言和操作系统的术语，是操作系统维护的一块动态分配内存；自由存储是C++中通过new与delete动态分配和释放对象的抽象概念。他们并不是完全一样。 从技术上来说，堆（heap）是C语言和操作系统的术语。堆是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当运行程序调用malloc()时就会从中分配，稍后调用free可把内存交还。而自由存储是C++中通过new和delete动态分配和释放对象的抽象概念，通过new来申请的内存区域可称为自由存储区。基本上，所有的C++编译器默认使用堆来实现自由存储，也即是缺省的全局运算符new和delete也许会按照malloc和free的方式来被实现，这时藉由new运算符分配的对象，说它在堆上也对，说它在自由存储区上也正确。 扩展: [堆和栈的区别（转过无数次的文章）](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F8aLQ2I_FsZZrFhnvM2rzlw)

### 10、关键字static的作用

1. 函数体内： static 修饰的局部变量作用范围为该函数体，不同于auto变量，其内存只被分配一次，因此其值在下次调用的时候维持了上次的值
2. 模块内：static修饰全局变量或全局函数，可以被模块内的所有函数访问，但是不能被模块外的其他函数访问，使用范围限制在声明它的模块内
3. 类中：修饰成员变量，表示该变量属于整个类所有，对类的所有对象只有一份拷贝
4. 类中：修饰成员函数，表示该函数属于整个类所有，不接受this指针，只能访问类中的static成员变量 注意和const的区别！！！const强调值不能被修改，而static强调唯一的拷贝，对所有类的对象

### 6、重载overload，覆盖（重写）override，隐藏（重定义）overwrite，这三者之间的区别

1. overload，将语义相近的几个函数用同一个名字表示，但是参数列表（参数的类型，个数，顺序不同）不同，这就是函数重载，返回值类型可以不同 
   - 特征：相同范围（同一个类中）、函数名字相同、参数不同、virtual关键字可有可无
2. override，派生类覆盖基类的虚函数，实现接口的重用，返回值类型必须相同 
   - 特征：不同范围（基类和派生类）、函数名字相同、参数相同、基类中必须有virtual关键字（必须是虚函数）
3. overwrite，派生类屏蔽了其同名的基类函数，返回值类型可以不同 
   - 特征：不同范围（基类和派生类）、函数名字相同、参数不同或者参数相同且无virtual关键字

### 2、C++中指针和引用的区别

1. 指针有自己的一块空间，而引用只是一个别名；
2. 使用 sizeof 看一个指针的大小为4字节（32位，如果要是64位的话指针为8字节），而引用则是被引用对象的大小；
3. 指针可以被初始化为 NULL，而引用必须被初始化且必须是一个已有对象的引用；
4. 作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；
5. 指针在使用中可以指向其他对象，但是引用只能是一个对象的引用，不能被改变；
6. 指针可以是多级，而引用没有分级；
7. 如果返回动态分配内存的对象或者内存，必须使用指针，引用可能引起内存泄漏。

**引用占用内存空间吗？** 对引用取地址，其实是取的引用所对应的内存空间的地址。这个现象让人觉得引用好像并非一个实体。但是引用是占用内存空间的，而且其占用的内存和指针一样，因为引用的内部实现就是通过指针来完成的。

### 9、C++中vector和list的区别

vector和数组类似，拥有一段连续的内存空间。vector申请的是一段连续的内存，当插入新的元素内存不够时，通常以2倍重新申请更大的一块内存，将原来的元素拷贝过去，释放旧空间。因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。 

list是由**双向链表**实现的，因此内存空间是不连续的。只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n); 但由于链表的特点，能高效地进行插入和删除。

vector拥有一段连续的内存空间，能很好的支持随机存取，因此vector::iterator支持“+”，“+=”，“<”等操作符。 list的内存空间可以是不连续，它不支持随机访问，因此list::iterator则不支持“+”、“+=”、“<”等 vector::iterator和list::iterator都重载了“++”运算符。 

总之，如果需要高效的随机存取，而不在乎插入和删除的效率，使用vector; 如果需要大量的插入和删除，而不关心随机存取，则应使用list。
