# 小红书

【多选题】关于Java中变量的作用域和生命周期，下列说法哪些是正确的（）ABD

A 局部变量的生命周期仅限于其所在的方法或代码块执行期间

B 静态变量属于类本身，在所有对象间共享

C 方法参数在整个程序运行期间都可以被访问

D 成员变量在对象被垃圾回收前一直存在，并且每个对象有独立的成员变量副本

【多选题】关于Java集合框架中的ArrayList和LinkedList，以下说法正确的是（）ABD
A. ArrayList基于动态数组实现，适合随机访问元素
B. LinkedList可以用作队列和栈，因为它实现了Deque接口
C. ArrayList和LinkedList都是线程安全的集合类
D. LinkedList基于双向链表实现，在列表中间插入和删除元素的效率的较高

【单选题】某医院按患者ID升序存储了以下检查记录（36,48,176,351,488,515,517,581,600,651,664,691, 735,758,778,794,959,976,995）。
若通过二分法查询患者ID为581的体检报告，成功匹配时需进行多少次关键值比对？（提示：mid=(low+high)/2向下取整）C

A 5
B 3
C 4
D 6

【多选题】关于Java中的基本数据类型和引用数据类型，下列说法哪些是正确的（）ACD
A 所有的基本数据类型都有对应的包装类
B 数组在Java中属于基本数据类型
C 引用数据类型保存的是对象的引用地址
D 局部变量中的基本数据类型变量存储在栈内存中
【解析】
数组是引用数据类型，而不是基本数据类型（即使数组元素是基本类型，数组本身也是对象）。
局部变量（包括基本类型和引用类型）存储在栈内存中，但引用类型变量存储的是地址，实际对象在堆中。

【单选题】某艺术品拍卖平台有如下数据库表结构；
Artworks
artwork_id（NT）： 艺术品缩号
artist （VARCHAR）：艺术家
title (VARCHAR): 名称
Bids
bid_id （INT）：出价缩号
artwork_id （INT）：艺术品结号
bid_amount（DECIMAL）：出价金额
要求查询每位艺术家的艺术品被出价的最高金额，正确的SQL语句是（）

```sql
SELECT artist, MAX(bid_amount)
FROM Artworks 
JOIN Bids ON Artworks.artwork_id = Bids.artwork_id
GROUP BY artist;
```

已知模式串 S="ababcaa"的 next数组为[0,0,0,1,2,0,1]，当主串T=“ababcabcabac"配到 T[7]时发生失配（数组下标从1开始，此时模式串需要移动的位数是（）

已知：
- 模式串 S = "ababcaa"（长度为7，下标从1开始）
- next数组为 [0,0,0,1,2,0,1]（即 next[1]=0, next[2]=0, next[3]=0, next[4]=1, next[5]=2, next[6]=0, next[7]=1）
- 主串 T = "ababcabcabac"
- 匹配到 T[7] 时发生失配（数组下标从1开始）

我们需要求此时模式串需要移动的位数。

**KMP算法中，当发生失配时，模式串移动的位数 = 已匹配的字符数 - 对应的next值**

具体步骤：
1. 确定失配时已匹配的字符数：
   - 匹配到 T[7] 时失配，说明主串 T 的前6个字符与模式串 S 的前6个字符已经匹配成功（因为失配发生在第7个字符）。
   - 即已匹配的字符数为6（因为模式串的前6个字符 "ababca" 已经匹配成功）。

2. 查找对应的next值：
   - 已匹配了6个字符，所以应该查看模式串第6个字符对应的next值，即 next[6] = 0。

3. 计算移动位数：
   - 移动位数 = 已匹配的字符数 - 对应的next值 = 6 - 0 = 6。

因此，模式串需要移动6位。

**验证：**
- 模式串 S: "ababcaa"
- 当前已匹配：主串 T 的前6个字符 "ababca"（与模式串前6位匹配），但 T[7] 与 S[7] 失配（假设 T[7] 不是 'a'）。
- 根据next数组，next[6]=0，所以下一步将模式串向右移动6位（即模式串的开头移动到当前已匹配开始位置的后一位），然后重新从模式串的第1个字符开始比较。

所以，移动位数是6。



假如我有一个data.txt文件，文件内容如下： 
apple 8 
banana 12 
orange 15 
我想打印出数量大于10的水果名字，用awk应该怎么实现？

```bash
awk '$2 > 10 {print $1}' data.txt
```

Linux中awk的用法

```bash
awk 'pattern { action }' input_file
```

- `pattern`: 匹配模式（可选）
- `action`: 执行的动作（必选）
- 处理流程：读取每行 → 匹配模式 → 执行动作



【单选题】在MySQL InnoDB存储引擎中，下列关于聚簇索引（Clustered Index）的描述错误的是（）D
A 如果表没有定义主键，InnoDB会选择一个唯一非空索引作为聚簇索引
B 聚簇索引的叶子结点存储了完整的数据而非指针
C 表的主键索引通常是聚簇索引
D 一个InnoDB表可以同时拥有多个聚簇索引以提高不能查询的性能
【解析】
如果没有主键，InnoDB会选择第一个唯一非空索引作为聚簇索引；如果也没有这样的索引，则会隐式创建一个隐藏的聚簇索引。
聚簇索引的叶子节点包含完整的行数据（即数据页），而不是指向数据的指针。
InnoDB表只能有一个聚簇索引，因为数据本身只能按照一种顺序物理存储（聚簇索引决定了数据的物理存储顺序）。多个聚簇索引会导致数据冗余和一致性维护问题。其他索引都是二级索引（非聚簇索引），其叶子节点存储主键值（而不是指针）。

【单选题】假这一个操作系统中，线程上下文切换的开销为5微秒（us），CPU时间片长度为5毫秒（ms）。如果一个进程中有3个线程，且这些线程在一个时间片内均匀地轮流执行一次，那么线程上下文切换的总开销占CPU时间的百分比是多少？

切换开销占比 = (总切换开销 / 总时间) × 100% = (0.01 / 5) × 100% = 0.2%。

## 算法题

时间限制：C/C++语言 1000M/S；其他语言 3000MS
内存限制：C/C++语言65536KB；其他语言 589824K8
题目描述：
小红是小红书的用户行为分析师。平台将每次用户行为映射为一个正整数权重序列${a_1,a_2,...a_n}$，以便后续关联提荐时提取关键“红色“行为。
为了保证标记的行为具有足够的共性，必须选出的所有 “红色“行为权重的最大公约数大于1；同时，为了避免相的行为产生冗余，所选下标不得相邻。
现给定用户的一次行为序列，求最多可以染成红色的行为数量。
【名词解释】
最大公约数：指一组整数共有的数中最大的一个。例如，12、18和30的公约数有1,2,3,6，其中最大的约数是6，因此gcd(12.18.30）=6。
输入描述
在一行上输入一个整数$n(1 \leq n  \leq 10^5)$，表示行为序列长度。
在第二行输入n个整数 ${a_1,a_2,...a_n}(1 \leq n  \leq 10^5)$  ，表示每次行为的权重值。
行上输出一个整数，来示最多可染红的行为数显。

输出描述

在一行上输出一个整数，表示最多可染红的行为数量

样例输入

```tex
5
1 2 3 2 6
```

样例输出

```tex
2
```

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
      	// 读取行为序列的长度n和序列本身
        int n = scanner.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }
        
      	// 生成2到100之间到所有质数，用于检查公共质因数
        List<Integer> primes = getPrimes(100);
        int maxCount = 0;
        
        for (int p : primes) {
            int[] dp = new int[n + 1];
            dp[0] = 0;
            if (n >= 1) {
                if (arr[0] % p == 0) {
                    dp[1] = 1;
                } else {
                    dp[1] = 0;
                }
            }
            for (int i = 2; i <= n; i++) {
                if (arr[i - 1] % p == 0) {
                    dp[i] = Math.max(dp[i - 1], dp[i - 2] + 1);
                } else {
                    dp[i] = dp[i - 1];
                }
            }
            maxCount = Math.max(maxCount, dp[n]);
        }
        
        System.out.println(maxCount);
    }
    
    private static List<Integer> getPrimes(int limit) {
        boolean[] isPrime = new boolean[limit + 1];
        Arrays.fill(isPrime, true);
        isPrime[0] = false;
        isPrime[1] = false;
        for (int i = 2; i * i <= limit; i++) {
            if (isPrime[i]) {
                for (int j = i * i; j <= limit; j += i) {
                    isPrime[j] = false;
                }
            }
        }
        List<Integer> primes = new ArrayList<>();
        for (int i = 2; i <= limit; i++) {
            if (isPrime[i]) {
                primes.add(i);
            }
        }
        return primes;
    }
}
```



题目：潜在同好



或者a能被

时间限制:C/C++语言2000MS; 

内存限制:C/C++语言 65536KB; 

题目描述:

在小红书平台的社交推荐项目中，产品团队希望基于用户的日常行为习惯分数，挖掘潜在的"同好”关系。

系统简化如下，数据库中有n个用户的日常行为习惯分数,第i个用户的分数使用$a_i$ 表示，记第 i 个用户和第j个用户构成“同好”关系，当且仅当$a_i$ 能被$a_j$ 整除，或者$a_j$ 能被$a_i$ 整除。

接下来将进行m次查询, 每次给定一个额外的用户行为分数x，请统计在数据库中，有多少不同的人能与这个人构成“同好”关系。 

输入描述 

第一行输入两个整数$n,m(1≤n,m≤5 \times 10^5)$,表示数据库中用户数量、查询次数。

第二行输入n个整数,$a_1,a_2,...a_n(1≤a_i≤5 \times 10^5)$,表示数据库中的用户日常行为习惯分数。

接下来m行，每行输入一个整数$x(1≤x≤5 \times 10^5)$，表示一个额外的用户行为习惯分数。

输出描述

对于每次查询，新起一行，输出一个整数，表示数据库中能与x构成“同好”关系的用户数量。

样例输入

```tex
5 3
1 2 2 5 6 
4
2
1 
```

样例输出 

```tex
3
4
5
```



```java
import java.io.*;
import java.util.*;

public class Main {
    static final int MAX = 500000;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        String[] firstLine = br.readLine().split(" ");
        int n = Integer.parseInt(firstLine[0]);
        int m = Integer.parseInt(firstLine[1]);
        
        int[] freq = new int[MAX + 1];
      	// 输入数据库中的用户日常行为习惯分数
        String[] data = br.readLine().split(" ");
      	// 统计每个数字出现的频率
        for (int i = 0; i < n; i++) {
            int num = Integer.parseInt(data[i]);
            if (num <= MAX) {
                freq[num]++;
            }
        }
        
      	// x的约数出现次数
        int[] F1 = new int[MAX + 1];
      	// x的倍数出现次数
        int[] F2 = new int[MAX + 1];
        
        // 计算F1: F1[i] = sum_{d|i} freq[d]
        for (int d = 1; d <= MAX; d++) {
            if (freq[d] == 0) continue;
            for (int j = d; j <= MAX; j += d) {
                F1[j] += freq[d];
            }
        }
        
        // 计算F2: F2[i] = sum_{j是i的倍数} freq[j]
        for (int i = 1; i <= MAX; i++) {
            for (int j = i; j <= MAX; j += i) {
                F2[i] += freq[j];
            }
        }
        
        for (int i = 0; i < m; i++) {
            int x = Integer.parseInt(br.readLine());
            if (x > MAX) {
                // 但x最大500000，所以不会超过
                bw.write("0\n");
            } else {
                int res = F1[x] + F2[x] - freq[x];
                bw.write(res + "\n");
            }
        }
        bw.flush();
    }
}
```

